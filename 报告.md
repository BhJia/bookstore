## 当代数据管理系统书店项目报告

| 课程名称：当代数据管理系统 | 年级：20级               |
| ------------------------------ | ---------------------------- |
| **指导教师：周煊**    | **组员：贾柏寒  杨一帆 薛沁晨** |

#### 一.相关功能实验要求

实现一个提供网上购书功能的网站后端。
网站支持书商在上面开商店，购买者可以通过网站购买。
买家和卖家都可以注册自己的账号。
一个卖家可以开一个或多个网上商店，
买家可以为自已的账户充值，在任意商店购买图书。
支持 下单->付款->发货->收货 流程。

1.实现对应接口的功能，见项目的doc文件夹下面的.md文件描述 （60%）

其中包括：

1)用户权限接口，如注册、登录、登出、注销

2)买家用户接口，如充值、下单、付款

3)卖家用户接口，如创建店铺、填加书籍信息及描述、增加库存

通过对应的功能测试，所有test case都pass 

2.为项目添加其它功能 ：（40%）

1)实现后续的流程 
发货 -> 收货

2)搜索图书 
用户可以通过关键字搜索，参数化的搜索方式；
如搜索范围包括，题目，标签，目录，内容；全站搜索或是当前店铺搜索。
如果显示结果较大，需要分页
(使用全文索引优化查找)

3)订单状态，订单查询和取消定单
用户可以查自已的历史订单，用户也可以取消订单。
取消定单可由买家主动地取消定单，或者买家下单后，经过一段时间超时仍未付款，定单也会自动取消。 



#### 二. 关系数据库设计及初始化

**1.概念设计**



**2.ER图**



**3.初始化**

① 利用SQLalchemy+ORM连接本地Postgresql数据库



② 建立表格

**book表**

```python
# 定义原始的图书表(按照markdown文件中的Schema)
class book(Base):
    __tablename__ = 'book'
    id = Column(Integer, primary_key=True, autoincrement=True)
    title = Column(Text, nullable=False)
    author = Column(Text, nullable=True)
    publisher = Column(Text, nullable=True)
    original_title = Column(Text, nullable=True)
    translator = Column(Text, nullable=True)
    pub_year = Column(Text, nullable=True)
    pages = Column(Integer, nullable=True)
    price = Column(Integer, nullable=True)
    binding = Column(Text, nullable=True)
    isbn = Column(Text, nullable=True)
    author_intro = Column(Text, nullable=True)
    book_intro = Column(Text, nullable=True)
    content = Column(Text, nullable=True)
    tags = Column(Text, nullable=True)
    # LargeBinary类型可以存储Blob类型文件
    picture = Column(LargeBinary, nullable=True)
```

字段解释:





③ 连接原先的sqlite数据库并将数据存储到postgresql数据库中



**4.可视化**



#### 三.功能实现

**1.用户权限接口相关功能**

① 注册

实现思路:



② 检查密码



③ 登陆



④ 登出



⑤ 注销



⑥ 修改密码



**2.买家用户接口相关功能**

① 下单

1.检查用户id和商家id是否存在

2.生成每个用户id和商家id的标识符uid

3.对于每一件要购买的书: 先查找商家和书籍信息,在商家表中查找商家id和书籍id, 判断书籍是否存在

4.获取库存量, 书籍信息, 书籍价格, 判断库存是否充足

5.更新商家图书信息: 先找到待更新商家图书, 判断是否库存不足, 然后更新库存

6.更新订单细节表new_order_detail

7.全部书籍查找结束后更新订单表new_order, 记录下单时间并设置状态status为已下单



② 支付

1.根据订单id查找订单, 判断订单是否存在

2.根据查找到订单的买家id, 判断买家用户信息是否一致

3.信息一致后查找买家用户并判断是否存在该买家

4.验证买家的密码是否正确

5.查找user_store表判断店铺是否存在

6.查找买家id判断是否存在

7.查找订单细节表, 计算订单总价判断用户是否有足够余额支付

8.查找订单表并更新订单总价, 设置订单状态为已支付, 记录订单支付时间

9.更新买家余额(注意卖家余额不需要更新, 因为用户支付后卖家不会立刻收到付款, 而是到确认订单后)



③ 充值

1.判断用户是否存在,密码是否输入正确

2.更新用户余额



④ 收货

1.查找用户id判断该用户是否存在

2.查找订单表判断订单是否在配送中(若待支付或已支付尚未配送则无法收货)

3.判断用户id和买家id是否一致

4.通过订单表取出卖家id, 查找卖家id判断卖家是否存在

5.通过订单表取出商铺id, 查找商铺id判断商铺是否存在

5.更新卖家余额



⑤ 查看历史订单

1.检查用户是否存在

2.分类查询: 可以查询所有订单, 已下单未支付的, 已支付未发货的, 已发货未收货的和取消的订单

3.对于每种查询, 两层循环, 第一层遍历所有订单取出订单id

4.第二层用订单id去订单细节表中查找每个订单的子订单信息并记录



⑥ 取消订单

1.判断用户是否存在

2.查找订单判断是否属于已下单未支付订单

3.如果订单属于已支付订单, 判断订单是否发货(已发货订单无法取消)

4.若订单属于已支付未发货订单, 则订单可以取消, 修改订单状态为已取消, 并未买家退款

5.若订单属于已下单未支付订单, 则直接修改订单状态为已取消



⑦ 搜索图书

1.首先判断买家id是否存在

2.设置查找的类型: 题目, 标签, 目录, 内容

3.判断是全站搜索还是当前店铺搜索

4.使用like进行搜索匹配

5.搜索后判断是否搜索成功并添加搜索信息

6.如果是当前店铺搜索则需要判断店铺id是否存在



⑧ 订单超时自动取消

1.设置最大待支付时间(这里为了方便测试设置为5s)

2.查找待支付订单(订单若已经支付后则无法取消)并获取下单时间

3.判断下单时间和当前时间差是否超过了最大支付时间, 若超过则取消订单, 并设置status为canceled





**3.卖家用户接口相关功能**

① 添加书籍

实现思路:

1.判断用户id,店铺id,书籍id是否存在

2.创建商铺对象, 包含书籍id,信息,库存

3.将商铺对象插入store表中



② 增加库存

1.判断用户id,店铺id,书籍id是否存在

2.根据store_id和book_id查找相关店铺

3.更新相关书籍库存



③ 发货

1.判断该用户(买家)是否存在

2.查找待发货订单并判断是否存在该订单

3.根据store_id判断买家身份是否一致

4.验证买家身份后修改订单状态为已发货



④ 创建店铺

1.判断用户id,店铺id是否存在

2.按照用户id,店铺id创建用户店铺关系对象加入user_store表



#### 四.功能测试

注: 1.原先的测试接口实现不变, 这里仅展示新加的测试接口实现

2.fe/access的调用接口和be/view的路由需要注意url的一致, 其余实现非常类似暂不展示

① test_cancel_order:

初始化:(初始化的过程每个测试文件基本相同,后续不再提及)

1.生成买家id, 卖家id, 店铺id

2.生成密码, 书籍id,书籍信息

3.注册买家

4.生成订单id

5.计算订单书籍总价格并给买家充值



测试:

1.测试已支付未发货后是否能正常取消

2.改变买家id判断是否会出错

3.判断确认收货后是否能取消



② test_deliver_order
初始化

测试:

1.测试已支付后订单是否能正常发货

2.测试修改卖家id后是否会出错

3.测试修改订单id后是否会出错



③ test_history_order

初始化

测试:

1.分类测试: 对于全部订单, 已下单未支付, 已支付未发货, 已发货未收货, 已取消订单分别测试

2.测试修改买家id是否会出错



④ test_receive_order

初始化

测试:
1.测试是否可以正常收货

2.测试修改买家id后是否会出错

3.测试修改订单id后是否会出错



⑤ test_search

初始化

测试:
1.对不同查询类型: 题目, 标签, 目录, 内容和查询范围: 全站, 当前店铺分别测试

2.测试修改买家id后是否会出错

3.测试修改商铺id后是否会出错



⑥ test_timeout_cancel

初始化

测试:
1.先测试未超时的订单, 再time.sleep一段时间使其超时判断是否会取消

2.测试已支付的订单是否可以取消





#### 五.优化

**1.索引**

创建索引以优化查询

① book表

id, title, book_intro, content, tags建立索引

```python
id = Column(Integer, primary_key=True, autoincrement=True,index=True)
title = Column(Text, nullable=False,index=True)
book_intro = Column(Text, nullable=True,index=True)
content = Column(Text, nullable=True,index=True)
tags = Column(Text, nullable=True,index=True)
```

创建表结果:

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208082840520.png" alt="image-20221208082840520" style="zoom:67%;" />



② usr表

user_id创建索引

```python
user_id = Column(Text, primary_key=True, unique=True,index=True)
```

创建表结果:

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208082946140.png" alt="image-20221208082946140" style="zoom:67%;" />



③ user_store表

user_id, store_id创建索引

```python
user_id = Column(Text, ForeignKey('user.user_id'), primary_key=True, nullable=False, index=True)
store_id = Column(Text, primary_key=True, nullable=False, unique=True,index=True)
```

创建表结果:
![image-20221208083111732](C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208083111732.png)



④ store表

store_id创建索引

```python
store_id = Column(Text, ForeignKey('user_store.store_id'), primary_key=True, nullable=False, index=True)
```

创建表结果:

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208083205836.png" alt="image-20221208083205836" style="zoom:67%;" />



⑤ new_order表

order_id创建索引

```python
order_id = Column(Text, primary_key=True,index=True)
```

创建表结果:

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208083252232.png" alt="image-20221208083252232" style="zoom: 67%;" />



⑥ new_order_detail表

order_id创建索引

```python
order_id = Column(Text, ForeignKey('new_order.order_id'), primary_key=True, nullable=False, index=True)
```

创建表结果:

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208083336304.png" alt="image-20221208083336304" style="zoom:67%;" />

**2.外键**

外键可以有效地加强表之间的关联, 同时保持数据的一致性与完整性

① user_store表

user_id指向user表的user_id

```python
user_id = Column(Text, ForeignKey('user.user_id'), primary_key=True, nullable=False, index=True)
```

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208085536944.png" alt="image-20221208085536944" style="zoom:67%;" />



② store表

store_id指向user_store的store_id(注意, 不能反向建立, 虽然都是商店表, 但后续创建商店的时候使用user_store创建而非store, 因此反向建立会发生错误)

book_id指向book的id

```python
store_id = Column(Text, ForeignKey('user_store.store_id'), primary_key=True, nullable=False, index=True)
book_id = Column(Integer, ForeignKey('book.id'), primary_key=True, nullable=False)
```

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208085753960.png" alt="image-20221208085753960" style="zoom:67%;" />



③ new_order表

user_id指向user.user_id

store_id指向user_store.store_id

```python
user_id = Column(Text, ForeignKey('user.user_id'), nullable=False)
store_id = Column(Text, ForeignKey('user_store.store_id'), nullable=False)
```

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208085851703.png" alt="image-20221208085851703" style="zoom: 67%;" />



③ new_order_detail表

order_id指向new_order的order_id

book_id指向book的id

```python
order_id = Column(Text, ForeignKey('new_order.order_id'), primary_key=True, nullable=False, index=True)
book_id = Column(Integer, ForeignKey('book.id'), primary_key=True, nullable=False)
```

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208090011129.png" alt="image-20221208090011129" style="zoom:67%;" />









#### 六.协作与版本管理



#### 七.总结
