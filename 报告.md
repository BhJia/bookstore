# 当代数据管理系统书店项目报告

| 课程名称：当代数据管理系统 | 年级：20级               |
| ------------------------------ | ---------------------------- |
| **指导教师：周煊**    | **组员：贾柏寒  杨一帆 薛沁晨** |



[TOC]

### 一.相关功能实验要求

实现一个提供网上购书功能的网站后端。
网站支持书商在上面开商店，购买者可以通过网站购买。
买家和卖家都可以注册自己的账号。
一个卖家可以开一个或多个网上商店，
买家可以为自已的账户充值，在任意商店购买图书。
支持 下单->付款->发货->收货 流程。

1.实现对应接口的功能，见项目的doc文件夹下面的.md文件描述 （60%）

其中包括：

1)用户权限接口，如注册、登录、登出、注销

2)买家用户接口，如充值、下单、付款

3)卖家用户接口，如创建店铺、填加书籍信息及描述、增加库存

通过对应的功能测试，所有test case都pass 

2.为项目添加其它功能 ：（40%）

1)实现后续的流程 
发货 -> 收货

2)搜索图书 
用户可以通过关键字搜索，参数化的搜索方式；
如搜索范围包括，题目，标签，目录，内容；全站搜索或是当前店铺搜索。
如果显示结果较大，需要分页
(使用全文索引优化查找)

3)订单状态，订单查询和取消定单
用户可以查自已的历史订单，用户也可以取消订单。
取消定单可由买家主动地取消定单，或者买家下单后，经过一段时间超时仍未付款，定单也会自动取消。 



### 二. 关系数据库设计及初始化

#### **1.概念设计**



#### **2.ER图**



#### **3.初始化**

① 利用SQLalchemy+ORM连接本地Postgresql数据库



② 建立表格

**book表**

```python
# 定义原始的图书表(按照markdown文件中的Schema)
class book(Base):
    __tablename__ = 'book'
    id = Column(Integer, primary_key=True, autoincrement=True)
    title = Column(Text, nullable=False)
    author = Column(Text, nullable=True)
    publisher = Column(Text, nullable=True)
    original_title = Column(Text, nullable=True)
    translator = Column(Text, nullable=True)
    pub_year = Column(Text, nullable=True)
    pages = Column(Integer, nullable=True)
    price = Column(Integer, nullable=True)
    binding = Column(Text, nullable=True)
    isbn = Column(Text, nullable=True)
    author_intro = Column(Text, nullable=True)
    book_intro = Column(Text, nullable=True)
    content = Column(Text, nullable=True)
    tags = Column(Text, nullable=True)
    # LargeBinary类型可以存储Blob类型文件
    picture = Column(LargeBinary, nullable=True)
```

字段解释:





③ 连接原先的sqlite数据库并将数据存储到postgresql数据库中







### 三.功能实现

#### **1.用户权限接口相关功能**

##### ① 注册

实现思路:



##### ② 检查密码



##### ③ 登陆



##### ④ 登出



##### ⑤ 注销



##### ⑥ 修改密码



#### **2.买家用户接口相关功能**

##### ① 下单

功能实现：

1. 首先保证用户id和store_id存在，若不存在返回对应用户信息

2. 通过user_id，store_id，和唯一标识符相连生成uid

3. 根据订单信息在store表中查找商户中是否存在对应书籍和足够的库存, 判断是否库存不足, 然后更新库存。

4. 若满足对应条件，则在store中的库存减去下单的数量，并向new_order_detail表插入order_id,book_id,count,price属性信息

   若库存不足，则返回error.error_stock_level_low(book_id) + (order_id,)

5. 将已经下单的订单的状态更改为ordered，并记录下单时间，以便之后取消订单使用

性能分析：

​         store表k次根据主键查询，k次更新，new_order_detail表k次插入，(k为订单中购买的书本数）new_order_unpaid表

##### ② 支付

功能实现：

1. 查询在new_order表中是否存在属于用户的待付订单，即status="ordered"，获取订单总价，商户id。
2. 若存在，根据user_id获取用户密码。并与用户输入密码对比。
3. 比对成功，且用户余额大于待付价格，则付款成功，否则失败，返回对应错误信息。
4. 若付款成功，在usr表中给给买家减少余额，根据买家id给增加卖家的余额
5. 将对应的new_order表的status改为paid
6. 记录当前时间，记录付款时间。

性能分析：
         一次查询 new_order table, 一次查询 users table, 一次查询 user_store table, 一次更新 users ，一次更新 new_order table，**访问数据库五次**。

##### ③ 充值

功能实现

1. 根据  user_id 获取用户密码
2. 将用户密码与用户输入的密码做对比
3. 若密码一致，则更新该用户在 users table 中的余额

性能分析

一次查询 users table，一次更新 users table，**访问数据库两次**

##### ④ 收货

功能实现

1. 根据 order_id 在 new_order table 中查询对应的订单状态，买家 id
2. 检查订单状态是否为已发货，订单id与买家id是否对应
3. 若符合条件，则更新卖家余额，更新订单状态为已收货并且加入历史记录

性能分析

一次查询 new_order table，一次查询 user_store table，两次更新 users table，一次查询 users table，**访问数据库五次** 

##### ⑤ 查看历史订单

为支持不同的查询订单需求，函数接口中除buyer_id另增加status。类似淘宝查询界面，支持查询用户所有订单，待付款订单，已付款待发货订单，已发货待收货订单，已收货订单，已取消订单。通过status进行区分。

功能实现：

查所有订单

1. 若用户不存在返回对应错误信息
2. 根据buyer_id查询new_order_detail
3. 查询成功，返回订单order_id，buyer_id，count和price信息。

查待待付款订单

1. 根据buyer_id,下单时间不为空以及status=="ordered"在new_order表中筛选记录
2. 对每一条记录，根order_id查询New_order_detail表，获取订单id，所购书籍列表（每本书的书名，价格，数量），下单时间，订单状态。
3. 将获取的记录包装成json对象，每个order下包含由订单id,下单时间，订单状态，所购书籍列表（书名，价格，数量）构成的数组。

查询已付款待发货订单，已发货待收货订单，已收货订单，已取消订单与查待待付款订单过程类似。只是返回订单状态不同，不再赘述。

性能分析：

​      查所有订单,查询待付款订单,查询已付款待发货订单,查询已发货待收货订单,查询已取消订单分别均为new_order表一次查询，对应不同状态，对应new_order表k次根据主键查询（k为new_order的该用户对应不同订单状态下的操作数）

##### ⑥ 取消订单

根据淘宝，如果卖家已发货需要申请售后来取消订单，这里我们只允许在未发货或未付款情况下才能取消订单

功能实现：

1. 根据order_id和buyer_id在new_order中判断是否为待付款订单
2. 若是，在new_order中更改对应订单状态为"cancelled"
3. 根据order_id和buyer_id在new_order中判断是否为待发货订单
4. 确定订单未发货后。在user表中更新买家余额增加该订单对应款项
5. 在new_order表中更改订单状态"paid"为"cancelled"。
6. 判断 new_order_detail中的order_id是否为用户输入order_id，book_id是否与store对应，在new_order_detail表中筛选记录，在store表中将对应的书籍的库存加回。
7. 若不是上述两种情况，返回无法取消订单

性能分析：

​           new_order表两次次查询，两次更新，new_order_detail表一次查询，store表k次更新（k为购买书籍数），user表两次根据user_id主键查询，两次更新（一次买家、一次卖家）。 

##### ⑦ 搜索图书



##### ⑧ 订单超时自动取消





#### **3.卖家用户接口相关功能**

##### ① 添加书籍

实现支持上架图书，将书籍添加到book表中并上架图书

这里传参接口增加price属性，需要商家自己定价，而不是传入书籍的零售价。

功能实现:

1. 检查user_id，store_id以及book_id是否已存在。若不存在返回对应错误信息
2. 将store_id, book_id, 出售价格插入store表。
3. 根据book_id从book表查询判断书是否已经在book表中
4. 如果不在，插入书籍的所有信息

注意该版本事务add_book是包括添加图书，将书籍添加到商店这两步

性能分析：

​       user表一次根据主键user_id查询，store表一次根据主键store_id查询，book表一次根据主键book_id查询,一次插入，store表一次插入。



##### ② 增加库存

功能实现

1. 检查user_id、store_id和book_id是否已存在。若不存在返回对应错误信息
2. 根据store_id, book_id对store表查询卖家商店中的书籍库存量，并在store表中更新库存，加上传入的库存数。

性能分析：
        user表一次根据主键user_id查询，store表一次根据store_id主键查询，一次更新。

##### ③ 发货

为了能保证设计的订单状态能相互转换，增加了发货函数

功能实现：

1. 根据传入的参数user_id获取用户信息，若记录不存在，返回`error.error_non_exist_user_id()`
2. 根据传入的参数order_id判断待发货的表里是否存在该记录，如果不存在，就返回`error_invalid_order_id(order_id)`
3. 判断订单中的卖家和传入的seller_id是否一致，如果不一致就返回`error_authorization_fail()`
4. 若订单存在，卖家存在且匹配，在new_order中将status从"paid"更改为"delivered"

性能分析：

​		user表一次查询；

​		new_order表一次查询，一次更新。



##### ④ 创建店铺

功能实现

1. 检查user_id和store_id是否已存在。若不存在返回对应错误信息
2. 插入用户id，新建店铺store_id至user_store表。

性能分析：
        usr表一次根据主键user_id查询，store表一次根据主键store_id查询，user_store表一次插入。

### 四.功能测试



### 五.优化



### 六.协作与版本管理



### 七.总结
