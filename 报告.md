## 当代数据管理系统书店项目报告

| 课程名称：当代数据管理系统 | 年级：20级               |
| ------------------------------ | ---------------------------- |
| **指导教师：周煊**    | **组员：贾柏寒  杨一帆 薛沁晨** |

#### 一.相关功能实验要求

实现一个提供网上购书功能的网站后端。
网站支持书商在上面开商店，购买者可以通过网站购买。
买家和卖家都可以注册自己的账号。
一个卖家可以开一个或多个网上商店，
买家可以为自已的账户充值，在任意商店购买图书。
支持 下单->付款->发货->收货 流程。

1.实现对应接口的功能，见项目的doc文件夹下面的.md文件描述 （60%）

其中包括：

1)用户权限接口，如注册、登录、登出、注销

2)买家用户接口，如充值、下单、付款

3)卖家用户接口，如创建店铺、填加书籍信息及描述、增加库存

通过对应的功能测试，所有test case都pass 

2.为项目添加其它功能 ：（40%）

1)实现后续的流程 
发货 -> 收货

2)搜索图书 
用户可以通过关键字搜索，参数化的搜索方式；
如搜索范围包括，题目，标签，目录，内容；全站搜索或是当前店铺搜索。
如果显示结果较大，需要分页
(使用全文索引优化查找)

3)订单状态，订单查询和取消定单
用户可以查自已的历史订单，用户也可以取消订单。
取消定单可由买家主动地取消定单，或者买家下单后，经过一段时间超时仍未付款，定单也会自动取消。 



#### 二. 关系数据库设计及初始化

**1.概念设计**



**2.ER图**



**3.初始化**

① 利用SQLalchemy+ORM连接本地Postgresql数据库



② 建立表格

**book表**

```python
# 定义原始的图书表(按照markdown文件中的Schema)
class book(Base):
    __tablename__ = 'book'
    id = Column(Integer, primary_key=True, autoincrement=True)
    title = Column(Text, nullable=False)
    author = Column(Text, nullable=True)
    publisher = Column(Text, nullable=True)
    original_title = Column(Text, nullable=True)
    translator = Column(Text, nullable=True)
    pub_year = Column(Text, nullable=True)
    pages = Column(Integer, nullable=True)
    price = Column(Integer, nullable=True)
    binding = Column(Text, nullable=True)
    isbn = Column(Text, nullable=True)
    author_intro = Column(Text, nullable=True)
    book_intro = Column(Text, nullable=True)
    content = Column(Text, nullable=True)
    tags = Column(Text, nullable=True)
    # LargeBinary类型可以存储Blob类型文件
    picture = Column(LargeBinary, nullable=True)
```

字段解释:





③ 连接原先的sqlite数据库并将数据存储到postgresql数据库中



**4.可视化**



#### 三.功能实现

**1.用户权限接口相关功能**

① 注册

实现思路:



② 检查密码



③ 登陆



④ 登出



⑤ 注销



⑥ 修改密码



**2.买家用户接口相关功能**

① 下单

1.检查用户id和商家id是否存在

2.生成每个用户id和商家id的标识符uid

3.对于每一件要购买的书: 先查找商家和书籍信息,在商家表中查找商家id和书籍id, 判断书籍是否存在

4.获取库存量, 书籍信息, 书籍价格, 判断库存是否充足

5.更新商家图书信息: 先找到待更新商家图书, 判断是否库存不足, 然后更新库存

6.更新订单细节表new_order_detail

7.全部书籍查找结束后更新订单表new_order, 记录下单时间并设置状态status为已下单



② 支付

1.根据订单id查找订单, 判断订单是否存在

2.根据查找到订单的买家id, 判断买家用户信息是否一致

3.信息一致后查找买家用户并判断是否存在该买家

4.验证买家的密码是否正确

5.查找user_store表判断店铺是否存在

6.查找买家id判断是否存在

7.查找订单细节表, 计算订单总价判断用户是否有足够余额支付

8.查找订单表并更新订单总价, 设置订单状态为已支付, 记录订单支付时间

9.更新买家余额(注意卖家余额不需要更新, 因为用户支付后卖家不会立刻收到付款, 而是到确认订单后)



③ 充值

1.判断用户是否存在,密码是否输入正确

2.更新用户余额



④ 收货

1.查找用户id判断该用户是否存在

2.查找订单表判断订单是否在配送中(若待支付或已支付尚未配送则无法收货)

3.判断用户id和买家id是否一致

4.通过订单表取出卖家id, 查找卖家id判断卖家是否存在

5.通过订单表取出商铺id, 查找商铺id判断商铺是否存在

5.更新卖家余额



⑤ 查看历史订单

1.检查用户是否存在

2.分类查询: 可以查询所有订单, 已下单未支付的, 已支付未发货的, 已发货未收货的和取消的订单

3.对于每种查询, 两层循环, 第一层遍历所有订单取出订单id

4.第二层用订单id去订单细节表中查找每个订单的子订单信息并记录



⑥ 取消订单

1.判断用户是否存在

2.查找订单判断是否属于已下单未支付订单

3.如果订单属于已支付订单, 判断订单是否发货(已发货订单无法取消)

4.若订单属于已支付未发货订单, 则订单可以取消, 修改订单状态为已取消, 并未买家退款

5.若订单属于已下单未支付订单, 则直接修改订单状态为已取消



⑦ 搜索图书

1.首先判断买家id是否存在

2.设置查找的类型: 题目, 标签, 目录, 内容

3.判断是全站搜索还是当前店铺搜索

4.使用like进行搜索匹配

5.搜索后判断是否搜索成功并添加搜索信息

6.如果是当前店铺搜索则需要判断店铺id是否存在



⑧ 订单超时自动取消

1.设置最大待支付时间(这里为了方便测试设置为5s)

2.查找待支付订单(订单若已经支付后则无法取消)并获取下单时间

3.判断下单时间和当前时间差是否超过了最大支付时间, 若超过则取消订单, 并设置status为canceled





**3.卖家用户接口相关功能**

① 添加书籍

实现思路:

1.判断用户id,店铺id,书籍id是否存在

2.创建商铺对象, 包含书籍id,信息,库存

3.将商铺对象插入store表中



② 增加库存

1.判断用户id,店铺id,书籍id是否存在

2.根据store_id和book_id查找相关店铺

3.更新相关书籍库存



③ 发货

1.判断该用户(买家)是否存在

2.查找待发货订单并判断是否存在该订单

3.根据store_id判断买家身份是否一致

4.验证买家身份后修改订单状态为已发货



④ 创建店铺

1.判断用户id,店铺id是否存在

2.按照用户id,店铺id创建用户店铺关系对象加入user_store表



#### 四.功能测试

注: 1.原先的测试接口实现不变, 这里仅展示新加的测试接口实现

2.fe/access的调用接口和be/view的路由需要注意url的一致, 其余实现非常类似暂不展示

① test_cancel_order:

初始化:(初始化的过程每个测试文件基本相同,后续不再提及)

1.生成买家id, 卖家id, 店铺id

2.生成密码, 书籍id,书籍信息

3.注册买家

4.生成订单id

5.计算订单书籍总价格并给买家充值



测试:

1.测试已支付未发货后是否能正常取消

2.改变买家id判断是否会出错

3.判断确认收货后是否能取消



② test_deliver_order
初始化

测试:

1.测试已支付后订单是否能正常发货

2.测试修改卖家id后是否会出错

3.测试修改订单id后是否会出错



③ test_history_order

初始化

测试:

1.分类测试: 对于全部订单, 已下单未支付, 已支付未发货, 已发货未收货, 已取消订单分别测试

2.测试修改买家id是否会出错



④ test_receive_order

初始化

测试:
1.测试是否可以正常收货

2.测试修改买家id后是否会出错

3.测试修改订单id后是否会出错



⑤ test_search

初始化

测试:
1.对不同查询类型: 题目, 标签, 目录, 内容和查询范围: 全站, 当前店铺分别测试

2.测试修改买家id后是否会出错

3.测试修改商铺id后是否会出错



⑥ test_timeout_cancel

初始化

测试:
1.先测试未超时的订单, 再time.sleep一段时间使其超时判断是否会取消

2.测试已支付的订单是否可以取消





#### 五.优化

**1.索引**

创建索引以优化查询

① book表

id, title, book_intro, content, tags建立索引

```python
id = Column(Integer, primary_key=True, autoincrement=True,index=True)
title = Column(Text, nullable=False,index=True)
book_intro = Column(Text, nullable=True,index=True)
content = Column(Text, nullable=True,index=True)
tags = Column(Text, nullable=True,index=True)
```

创建表结果:

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208082840520.png" alt="image-20221208082840520" style="zoom:67%;" />



② usr表

user_id创建索引

```python
user_id = Column(Text, primary_key=True, unique=True,index=True)
```

创建表结果:

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208082946140.png" alt="image-20221208082946140" style="zoom:67%;" />



③ user_store表

user_id, store_id创建索引

```python
user_id = Column(Text, ForeignKey('user.user_id'), primary_key=True, nullable=False, index=True)
store_id = Column(Text, primary_key=True, nullable=False, unique=True,index=True)
```

创建表结果:
![image-20221208083111732](C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208083111732.png)



④ store表

store_id创建索引

```python
store_id = Column(Text, ForeignKey('user_store.store_id'), primary_key=True, nullable=False, index=True)
```

创建表结果:

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208083205836.png" alt="image-20221208083205836" style="zoom:67%;" />



⑤ new_order表

order_id创建索引

```python
order_id = Column(Text, primary_key=True,index=True)
```

创建表结果:

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208083252232.png" alt="image-20221208083252232" style="zoom: 67%;" />



⑥ new_order_detail表

order_id创建索引

```python
order_id = Column(Text, ForeignKey('new_order.order_id'), primary_key=True, nullable=False, index=True)
```

创建表结果:

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208083336304.png" alt="image-20221208083336304" style="zoom:67%;" />

**2.外键**

外键可以有效地加强表之间的关联, 同时保持数据的一致性与完整性

① user_store表

user_id指向user表的user_id

```python
user_id = Column(Text, ForeignKey('user.user_id'), primary_key=True, nullable=False, index=True)
```

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208085536944.png" alt="image-20221208085536944" style="zoom:67%;" />



② store表

store_id指向user_store的store_id(注意, 不能反向建立, 虽然都是商店表, 但后续创建商店的时候使用user_store创建而非store, 因此反向建立会发生错误)

book_id指向book的id

```python
store_id = Column(Text, ForeignKey('user_store.store_id'), primary_key=True, nullable=False, index=True)
book_id = Column(Integer, ForeignKey('book.id'), primary_key=True, nullable=False)
```

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208085753960.png" alt="image-20221208085753960" style="zoom:67%;" />



③ new_order表

user_id指向user.user_id

store_id指向user_store.store_id

```python
user_id = Column(Text, ForeignKey('user.user_id'), nullable=False)
store_id = Column(Text, ForeignKey('user_store.store_id'), nullable=False)
```

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208085851703.png" alt="image-20221208085851703" style="zoom: 67%;" />



④ new_order_detail表

order_id指向new_order的order_id

book_id指向book的id

```python
order_id = Column(Text, ForeignKey('new_order.order_id'), primary_key=True, nullable=False, index=True)
book_id = Column(Integer, ForeignKey('book.id'), primary_key=True, nullable=False)
```

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221208090011129.png" alt="image-20221208090011129" style="zoom:67%;" />









#### 六.协作与版本管理

**1.github协作**

使用Github与Git进行协作与版本控制

我们使用了creator和collaborator的模型进行写作, 创建者和协作者都可以直接修改提交项目并同步更新项目

**创建者**

① Github创建仓库

② 为仓库添加collaborator

协作者收到邮件确认后即可加入项目开发

![image-20221205154007250](C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221205154007250.png)

③ 创建者在本地clone仓库(使用SSH), 并设置用户名和邮箱

```
git config user.name "name"
git config user.email "email"
```

④ 创建分支

由于一般项目开发都是先使用开发版本, 最后再合并为最终版本, 因此在本地创建分支dev并push到远程, 这样本地和远程都有新分支dev, 之后的开发都是在dev上进行 

```
# 创建本地分支dev
git checkout -b dev

# push到远程
git push origin dev
```

⑤ 将文件提交到远程仓库

把已经写好的代码提交到dev分支

```
git add <filename>  # 或添加全部文件git add .
git status   # 查看状态信息
git commit -m "message"
git push <远程主机名> <本地分支名>:<远程分支名>  
# 如果本地分支名与远程分支名相同，则可以省略冒号
git push <远程主机名> <本地分支名>  # git push -u origin dev
```

![image-20221205180704924](C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221205180704924.png)





**协作者**

① 协作者在作为collaborator加入项目后, 同样先将远程仓库clone到本地, 设置用户名邮箱, 创建和创建者使用分支相同名称的分支

② 在提交更新前先要同步本地仓库

```
git pull <远程主机名> <远程分支名>:<本地分支名>
# 如果远程分支是与当前分支合并，则冒号后面的部分可以省略
git pull <远程主机名> <远程分支名> # git pull origin dev
```

③ 提交变更, 方法和创建者相同, 此时创建者可以看到变更, 创建者需要同步更新仓库





**Pycharm中使用Git**

在settings-Version Control中配置Git路径, 之后打开clone的项目就可以使用Git

代码变动后左侧会有提示

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221205191834886.png" alt="image-20221205191834886" style="zoom:67%;" />

可以使用图形化界面进行update, commit,push等操作

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221205191900262.png" alt="image-20221205191900262" style="zoom:67%;" />

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221205194631146.png" alt="image-20221205194631146" style="zoom: 67%;" />

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221205194658057.png" alt="image-20221205194658057" style="zoom:67%;" />

可以看到版本变更:

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221205194829927.png" alt="image-20221205194829927" style="zoom:67%;" />

点开可以查看具体变更信息:
<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221205194929162.png" alt="image-20221205194929162" style="zoom:67%;" />



**工程问题**: 

① 进行update若出现以下错误: dev has no tracked branch

![image-20221205192050374](C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221205192050374.png)

分析: git有三种分支, 远程分支, 远程跟踪分支, 跟踪分支

远程分支(remote branch):即远程仓库的分支, 比如这里的main和dev

远程跟踪分支(remote-tracking branch): 本地仓库对远程仓库中的某个远程分支的状态的记录, 以**远程仓库名/远程分支名**来命名, 例如想查看最后一次与远程仓库origin通信时dev分支的情况, 那么就要查看远程跟踪分支origin/dev; 远程跟踪分支的作用是告诉用户其所跟踪的远程分支的状态（即指向哪一个commit），因而它在本地是只读的，用户是无法自行修改它的指向

跟踪分支(tracking branch): 从一个远程跟踪分支产生出的一个本地分支便是跟踪分支，该本地分支对应的远程跟踪分支称为上游分支(upstream branch), 跟踪分支为本地分支和远程分支之间建立了一种联系，方便了远程分支和本地分支的同步

当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/main 的 main 分支(跟踪分支), 也可以checkout创建新分支

那么这样的报错就是由于没有设置远程跟踪分支导致的, 只要指定远程跟踪分支(上游分支即可)

方法1: 直接设置远程追踪分支

```
git branch --set-upstream-to origin/dev
```

方法2:-u即记住这个远程追踪分支, 下次就不需要设置

```
git push -u origin master
```



②Push Rejected

原因: 本地仓库和远程仓库版本不一样

解决方案: ①先pull 更新本地仓库  ②本地创建新分支, 旧分支pull之后和新分支合并再push即可

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221205223033502.png" alt="image-20221205223033502" style="zoom:67%;" />



③The following untracked working tree files would be overwritten by merge

原因: 创建仓库的时候忘记加.gitignore文件, 导致协作者提交了很多idea的配置文件，然后创建者pull了之后会报错, 因为配置文件重复了

解决方法: Pycharm装插件.ignore, 然后新建一个.gitignore文件即可解决

<img src="C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221206080801760.png" alt="image-20221206080801760" style="zoom:67%;" />

![image-20221206080934771](C:\Users\寒\AppData\Roaming\Typora\typora-user-images\image-20221206080934771.png)

注意: 一般情况下该报错信息的解决方案:

使用下面的命令删除没有被track的文件(没有add或commit)的

```
git clean -d -fx
```



#### 七.总结
